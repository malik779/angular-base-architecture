# Angular Advanced Multi-Tenant Architecture

A production-ready Angular application implementing advanced multi-tenant architecture with authentication, authorization, and comprehensive UI components.

## Features

- **Multi-Tenant Architecture**: Opt-in tenant support with subdomain, path, and query parameter resolution
- **Authentication & Authorization**: JWT-based auth with role and permission guards
- **Shared UI Components**: PrimeNG grids, Angular Material modals, and reusable controls
- **Performance Optimized**: Lazy loading, OnPush change detection, and memory leak prevention
- **State Management**: NgRx for global state, Signals for local UI state
- **API Layer**: Centralized service with caching, error handling, and interceptors
- **Global Loading**: Prevents flickering during navigation and API calls
- **Security**: Content Security Policy, secure token storage, and server-side validation

## Architecture Overview

```
src/
├── app/
│   ├── core/                    # Singletons (CoreModule)
│   │   ├── auth/                # AuthService, TokenStore, interceptors
│   │   ├── api/                 # ApiService base, HttpFactories
│   │   ├── config/              # Runtime config + AppConfigService
│   │   ├── tenant/              # TenantService, TenantContext
│   │   ├── guards/              # AuthGuard, RoleGuard, PermissionGuard
│   │   ├── directives/          # *hasPermission, *hasRole
│   │   ├── ui/                  # Global UI helpers (snackbars, loader)
│   │   └── interceptors/        # auth, error, timing
│   ├── shared/                  # Shared components, pipes, models
│   │   ├── components/
│   │   │   ├── shared-grid/     # PrimeNG grid wrapper
│   │   │   ├── search-input/   # Debounce search control
│   │   │   └── modal-host/     # Material modal wrapper
│   │   ├── directives/
│   │   ├── models/
│   │   └── services/
│   └── features/               # Feature modules (lazy-loaded)
│       ├── orders/
│       ├── products/
│       └── admin/
├── assets/
└── environments/
```

## Quick Start

### Prerequisites

- Node.js 18+ 
- npm or yarn
- Angular CLI 18+

### Installation

1. **Clone and install dependencies:**
   ```bash
   npm install
   ```

2. **Start development server:**
   ```bash
   npm start
   ```

3. **Build for production:**
   ```bash
   npm run build
   ```

### Configuration

The application uses runtime configuration loaded from `/assets/runtime-config.json`. This file is generated by your backend or CI/CD pipeline and contains:

```json
{
  "apiBaseUrl": "http://localhost:3000/api",
  "identityServerUrl": "http://localhost:5000",
  "clientId": "angular-multitenant-app",
  "tenantMode": true,
  "features": {
    "orders": true,
    "products": true,
    "admin": true
  },
  "theme": {
    "primary": "#3f51b5",
    "secondary": "#ff4081"
  }
}
```

## Multi-Tenant Setup

The application supports multiple tenant resolution strategies:

1. **Query Parameter**: `?tenant=TENANT_ID`
2. **Path Segment**: `/t/TENANT_ID/...` or `/tenant/TENANT_ID/...`
3. **Subdomain**: `tenant.example.com`
4. **JWT Claim**: `tenant_id` claim in authentication token
5. **Default**: Single-tenant mode fallback

### Tenant Configuration

Each tenant can have:
- Custom branding (theme, logo)
- Feature toggles
- Custom settings
- Metadata

## Authentication & Authorization

### Guards

- **AuthGuard**: Prevents unauthenticated access
- **RoleGuard**: Checks user roles (`roleGuard(['admin'])`)
- **PermissionGuard**: Checks fine-grained permissions (`permissionGuard(['orders.view'])`)

### Directives

- **hasRole**: Show/hide elements based on roles
- **hasPermission**: Show/hide elements based on permissions

### Usage Examples

```typescript
// Route protection
{
  path: 'admin',
  canActivate: [authGuard, roleGuard(['admin'])],
  loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule)
}

// Template directives
<div *hasRole="'admin'">Admin content</div>
<button *hasPermission="'orders.create'">Create Order</button>
```

## Shared Components

### SharedGridComponent

A powerful data grid wrapper around PrimeNG's p-table:

```typescript
<app-shared-grid
  [columns]="columns"
  [data]="data$"
  [totalRecords]="totalRecords"
  [loading]="loading"
  [lazy]="true"
  [pageSize]="10"
  [selectionMode]="'multiple'"
  (lazyLoad)="onLazyLoad($event)"
  (sort)="onSort($event)"
  (selectionChange)="onSelectionChange($event)">
</app-shared-grid>
```

### SearchInputComponent

Debounced search input with suggestions:

```typescript
<app-search-input
  placeholder="Search..."
  [debounceTime]="300"
  (valueChange)="onSearch($event)">
</app-search-input>
```

## API Service

Centralized API service with built-in features:

```typescript
// Basic usage
this.apiService.get<User[]>('users').subscribe(users => {
  // Handle users
});

// Cached requests
this.apiService.getCached<Product[]>('products', 300000).subscribe(products => {
  // Cached for 5 minutes
});

// Paginated requests
this.apiService.getPaginated<Order>('orders', 1, 10).subscribe(response => {
  // response.data, response.total, response.page, etc.
});
```

## State Management

### NgRx for Global State

```typescript
// Actions
export const loadUsers = createAction('[Users] Load Users');
export const loadUsersSuccess = createAction(
  '[Users] Load Users Success',
  props<{ users: User[] }>()
);

// Effects
@Injectable()
export class UsersEffects {
  loadUsers$ = createEffect(() =>
    this.actions$.pipe(
      ofType(loadUsers),
      switchMap(() =>
        this.apiService.get<User[]>('users').pipe(
          map(users => loadUsersSuccess({ users }))
        )
      )
    )
  );
}
```

### Signals for Local State

```typescript
export class MyComponent {
  // Signal-based local state
  searchTerm = signal('');
  results = computed(() => 
    this.searchTerm().length > 2 ? this.performSearch(this.searchTerm()) : []
  );
}
```

## Performance Best Practices

1. **OnPush Change Detection**: All components use `ChangeDetectionStrategy.OnPush`
2. **Async Pipe**: Prefer async pipe over manual subscriptions
3. **Lazy Loading**: All feature modules are lazy-loaded
4. **Memory Leak Prevention**: Use `takeUntil` pattern or component signals
5. **Virtual Scrolling**: Built into SharedGridComponent for large datasets

## Security Features

1. **Content Security Policy**: Configure CSP headers
2. **Secure Token Storage**: HTTP-only cookies for refresh tokens
3. **XSS Protection**: Sanitized inputs and outputs
4. **CSRF Protection**: Built-in Angular CSRF handling
5. **Server-Side Validation**: Never trust client-side validation

## Production Checklist

- [ ] Configure CSP headers
- [ ] Enable SRI for external scripts
- [ ] Set up secure cookies for refresh tokens
- [ ] Configure proper CORS policies
- [ ] Set up monitoring and logging
- [ ] Configure CDN for static assets
- [ ] Set up automated security scanning
- [ ] Configure proper error handling and logging

## Development

### Adding New Features

1. Create feature module in `src/app/features/`
2. Add lazy-loaded route in `app-routing.module.ts`
3. Implement guards and permissions as needed
4. Use shared components for consistency

### Adding New Shared Components

1. Create component in `src/app/shared/components/`
2. Export from appropriate module
3. Add to component imports as needed

## Troubleshooting

### Common Issues

1. **Flickering during navigation**: Ensure global loading service is properly configured
2. **Memory leaks**: Use `takeUntil` pattern or component signals
3. **Performance issues**: Check for unnecessary change detection cycles
4. **Authentication issues**: Verify token storage and refresh logic

## Contributing

1. Follow Angular style guide
2. Use TypeScript strict mode
3. Write unit tests for new features
4. Update documentation for API changes

## License

MIT License - see LICENSE file for details.